import React from 'react';
import AltContainer from 'alt/AltContainer';
import {VersionStore} from '../stores/VersionStore';
import VersionActions from '../actions/VersionActions';
import Immutable from 'immutable';
import classNames from 'classnames';
import appdata from '../appdata';

const SQUIRE_PATH = appdata.get('squireUrl');

const formRowWrapper = function(htmlFor, label, elem) {
    const labelEl = label ? (<label className="control-label" htmlFor={htmlFor}>{label}</label>) : null;
    return (
        <div className="form-group">
            {labelEl}
            {elem}
        </div>
    );
};

class FormInput extends React.Component {
    onChange(event) {
        let value = event.target.value;
        this.props.onChange(value);
    }

    render() {
        // TODO: allow id to be autogenerated if not passed in
        let id = 'FormRow-' + this.props['data-id'];
        let field = (<input type="text" className="form-control input-sm" id={id} value={this.props.value} onChange={this.onChange.bind(this)}/>);
        return formRowWrapper(id, this.props.label, field);
    }
}


class FormTextArea extends React.Component {
    onChange(event) {
        let value = event.target.value;
        this.props.onChange(value);
    }

    render() {
        // TODO: allow id to be autogenerated if not passed in
        let id = 'FormRow-' + this.props['data-id'];
        let field = (<textarea className="form-control" rows="20" id={id} value={this.props.value} onChange={this.onChange.bind(this)} />);
        return field;
    }
}


class SquireEditor extends React.Component {
    constructor(props) {
        super(props);
        this.state = {currentValue: props.value};
    }

    loaded() {
        return (evt) => {
            let editor = React.findDOMNode(this.refs.squireEditor).contentWindow.editor;
            editor.addEventListener('input', this.changed());
            this.editor = editor;
            this.editor.setHTML(this.props.value);
        };
    }
    changed() {
        return () => {
            let newValue = this.editor.getHTML();
            this.setState({currentValue: newValue});
            this.props.onChange(newValue);
        };
    }
    refreshView(props) {
        if (this.editor && props.value && props.value !== this.state.currentValue) {
            this.editor.setHTML(props.value);
        }
    }
    shouldComponentUpdate() {
        // Let's just never update this component again.
        return false;
    }
    componentWillReceiveProps(nextProps) {
        this.refreshView(nextProps);
        this.setState({currentValue: nextProps.value});
    }
    render() {
        return (
            <div ref="squireContainer">
                <iframe ref="squireEditor" style={{width: '100%', height: '500px'}} src={SQUIRE_PATH} onLoad={this.loaded()}  />
            </div>
        );
    }
}

class VersionForm extends React.Component {
    constructor(props) {
        super(props);
        this.state = this.makeState(props);
    }

    makeState(props) {
        var state = {};
        state.data = Immutable.Map({
            editSummary: '',
            html: props.version.html,
            activeTab: 'source'
        });
        return state;
    }
    resetHandler() {
        return () => {
            this.setState(this.makeState(this.props));
        };
    }
    componentWillReceiveProps(nextProps) {
        this.setState(this.makeState(nextProps));
    }
    changeHandler(field) {
        return (value) => {
            this.setState({data: this.state.data.set(field, value)});
        };
    }
    tabClickHandler(newTab) {
        return (evt) => {
            evt.preventDefault();
            this.setState({data: this.state.data.set('activeTab', newTab)});
        };
    }

    getHtmlView() {
        return {
            __html: this.state.data.get('html')
        };
    }

    saveHandler() {
        return () => {
            let save = {
                'edit_summary': this.state.data.get('editSummary'),
                'html': this.state.data.get('html'),
                'writeuppost_id': this.props.version.writeuppost_id,
                'threadpost_id': this.props.version.threadpost_id
            };
            VersionActions.saveVersion(save);
        };
    }

    render() {
        let canSave = this.state.data.get('editSummary').length > 0;
        return (
            <div>
                <FormInput data-id="editSummary" label="Edit Summary" value={this.state.data.get('editSummary')} onChange={this.changeHandler('editSummary')} />
                <button type="button" onClick={this.saveHandler()} className="btn btn-success" disabled={!canSave}>Save</button>
                <button type="button" onClick={this.resetHandler()} className="btn btn-danger pull-right">Reset</button>
                <ul className="nav nav-tabs nav-justified">
                    <li role="presentation" className={classNames({'active': this.state.data.get('activeTab') === 'source'})}><a href="#" onClick={this.tabClickHandler('source')}>Source</a></li>
                    <li role="presentation" className={classNames({'active': this.state.data.get('activeTab') === 'squire'})}><a href="#" onClick={this.tabClickHandler('squire')}>Squire</a></li>
                    <li role="presentation" className={classNames({'active': this.state.data.get('activeTab') === 'view'})}><a href="#" onClick={this.tabClickHandler('view')}>View</a></li>
                </ul>
                <div className={classNames({'hidden': this.state.data.get('activeTab') !== 'source'})}>
                    <FormTextArea data-id="html" value={this.state.data.get('html')} onChange={this.changeHandler('html')} />
                </div>
                <div className={classNames({'hidden': this.state.data.get('activeTab') !== 'squire'})}>
                    <SquireEditor value={this.state.data.get('html')} onChange={this.changeHandler('html')} />
                </div>
                <div className={classNames({'hidden': this.state.data.get('activeTab') !== 'view'})}>
                    <div dangerouslySetInnerHTML={this.getHtmlView()} />
                </div>
            </div>
        );
    }
}


export default class VersionEditor extends React.Component {
    static onEnter(nextState, replaceState, callback) {
        const params = nextState.params;
        const wpvId = parseInt(params.id, 10);
        if (isNaN(wpvId)) {
            return callback(wpvId);
        }
        var p = VersionStore.fetchVersion(wpvId);
        p.then(() => {callback(); }).catch((error) => {callback(error.message); });
    }

    render() {
        /*
         * If this.name === 'new-version', the PostStore will be empty.
           In this case, we need to collect the url.
         */
        return (
            <div className="container">
                <AltContainer store={VersionStore}>
                    <VersionForm version={this.props.version} />
                </AltContainer>
            </div>
        );
    }
}
